import StyleDictionary from 'style-dictionary';

// Minimal custom format: extends standard css/variables with theme grouping
const variablesThemesFormat = ({ dictionary, options }) => {
  const { selector = ':root' } = options;
  
  // Group tokens by theme using standard dictionary.allTokens
  const lightColors = [];
  const darkColors = [];
  const sharedTokens = [];
  
  dictionary.allTokens.forEach(token => {
    // Check if token belongs to a theme based on its path
    if (token.path.includes('md/Light')) {
      if (token.type === 'color') {
        lightColors.push(token);
      } else {
        sharedTokens.push(token);
      }
    } else if (token.path.includes('md/Dark')) {
      if (token.type === 'color') {
        darkColors.push(token);
      }
    } else {
      sharedTokens.push(token);
    }
  });
  
  let output = `/* Design Tokens - CSS Variables */\n`;
  output += `/* Generated by: Style Dictionary */\n`;
  output += `/* DO NOT EDIT MANUALLY */\n\n`;
  
  // Light theme
  output += `${selector},\n.theme-light {\n`;
  
  // Colors (light theme)
  if (lightColors.length > 0) {
    output += `  /* Color - Light Theme */\n`;
    lightColors.forEach(token => {
      const name = token.path
        .filter(p => !['md/Light', 'md', 'sys', 'color', 'ref'].includes(p))
        .join('-');
      output += `  --md-sys-color-${name}: ${token.value};\n`;
    });
    output += `\n`;
  }
  
  // Shared Tokens (Typography, Shape, Elevation)
  output += `  /* Shared Tokens */\n`;
  sharedTokens.forEach(token => {
    // Handle Typography
    if (token.type === 'typography') {
      const name = token.path
        .filter(p => !['md/Light', 'md', 'sys', 'typography', 'typescale'].includes(p))
        .join('-');
      
      if (typeof token.value === 'object') {
        Object.entries(token.value).forEach(([prop, val]) => {
          const cssProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
          output += `  --md-sys-typography-${name}-${cssProp}: ${val};\n`;
        });
      }
    } 
    // Handle Shape
    else if (token.type === 'borderRadius') {
      const name = token.path
        .filter(p => !['md/Light', 'md', 'sys', 'shape', 'corner'].includes(p))
        .join('-');
      output += `  --md-sys-shape-${name}: ${token.value};\n`;
    } 
    // Handle Elevation
    else if (token.type === 'boxShadow') {
      const name = token.path
        .filter(p => !['md/Light', 'md', 'sys', 'elevation', 'level'].includes(p))
        .join('-');
      output += `  --md-sys-elevation-${name}: ${token.value};\n`;
    }
    // Handle other refs (like palettes)
    else if (token.path.includes('ref')) {
      const name = token.path
        .filter(p => !['md/Light', 'md', 'ref'].includes(p))
        .join('-');
      output += `  --md-ref-${name}: ${token.value};\n`;
    }
  });
  
  output += `}\n\n`;
  
  // Dark theme
  if (darkColors.length > 0) {
    output += `.theme-dark {\n`;
    output += `  /* Color - Dark Theme */\n`;
    darkColors.forEach(token => {
      const name = token.path
        .filter(p => !['md/Dark', 'md', 'sys', 'color', 'ref'].includes(p))
        .join('-');
      output += `  --md-sys-color-${name}: ${token.value};\n`;
    });
    output += `\n  /* Typography, Shape, and Elevation remain the same */\n`;
    output += `}\n`;
  }
  
  return output;
};

const config = {
  source: ['src/tokens/tokens.json'],
  hooks: {
    formats: {
      'css/variables-themes': variablesThemesFormat,
    },
  },
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'src/styles/',
      files: [
        {
          destination: 'tokens.css',
          format: 'css/variables-themes',
          options: {
            selector: ':root',
          },
        },
      ],
    },
  },
  log: {
    verbosity: 'silent'
  }
};

const sd = new StyleDictionary(config);
await sd.buildAllPlatforms();
